#' Export LakeEnsemblR standardized input to model specific driver format
#'
#'Export driver files for each model
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include c('GOTM', 'GLM', 'Simstrat', 'FLake')
#' @param meteo_file filepath; to met file which is in the standardised LakeEnsemblR format. Uses
#' @param lhc_file filepath to results from Latin Hypercube sampling from run_Latin_hypercube(). Defaults to NULL
#' @param metric character; metric to extract best scaling factors, can be 'RMSE', 'NSE', 'Pearson_r', 'MAE'. Defaults to RMSE
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#' export_meteo(model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#' }
#' @importFrom gotmtools get_yaml_value calc_cc input_yaml
#' @importFrom glmtools read_nml set_nml write_nml
#'
#' @export


export_meteo <- function(config_file, model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file = NULL, lhc_file = NULL, metric = 'RMSE', folder = '.'){

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz = Sys.getenv("TZ")
  Sys.setenv(TZ="GMT")

  # Set working directory
  oldwd <- getwd()

  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ=original_tz)
  })


  # get lat and lon - currently hack getting from GOTM but maybe could be in global config file?
  yaml = file.path(folder,config_file)

  # Function to be added to gotmtools
  lat <- get_yaml_value(file = yaml, label = 'location', key = 'latitude')
  lon <- get_yaml_value(file = yaml, label = 'location', key = 'longitude')

  ### Import data
  # I'd prefer to use a function that can read both comma and tab delimited. data.table::fread does this, but then it's data.table
  message('Loading met data...')
  if(is.null(meteo_file)){
    meteo_file <- get_yaml_value(file = yaml, label = 'meteo', key = 'meteo_file')
  }
  met = read.csv(file.path(folder, meteo_file), stringsAsFactors = F)
  met[,1] <- as.POSIXct(met[,1])
  # Check time step
  tstep <- diff(as.numeric(met[,1]))

  if((mean(tstep) - 86400)/86400 < -0.05){
    daily = FALSE
    subdaily = TRUE
  } else {
    daily = TRUE
    subdaily = FALSE
  }

  # # Is data daily? - For cloud cover calculation
  # if(sum(tstep != 86400) > 0){
  #   daily = FALSE
  #   subdaily = TRUE
  # }else{
  #   daily = TRUE
  #   subdaily = FALSE
  # }

  ### Naming conventions standard input
  # Depending on the setup of the standard config file, we can omit reading exact titles and read column numbers
  colname_time = "datetime"
  colname_wind_speed = "Ten_Meter_Elevation_Wind_Speed_meterPerSecond"
  colname_wind_direction = "Ten_Meter_Elevation_Wind_Direction_degree"
  colname_air_temperature = "Air_Temperature_celsius"
  colname_dewpoint_temperature = "Dewpoint_Temperature_celsius"
  colname_relative_humidity = "Relative_Humidity_percent"
  colname_solar_radiation = "Shortwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_longwave_radiation = "Longwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_surface_pressure = "Surface_Level_Barometric_Pressure_pascal"
  colname_precipitation = "Precipitation_meterPerSecond"
  colname_snow = "Snowfall_meterPerDay"
  colname_vapour_pressure = "Vapor_Pressure_milliBar"
  colname_cloud_cover = "Cloud_Cover_decimalFraction"

  ### Check what met data is available, as this determines what model forcing option to use (in the simstrat config file)
  datetime = colname_time %in% colnames(met)
  wind_speed = colname_wind_speed %in% colnames(met)
  wind_direction = colname_wind_direction %in% colnames(met)
  air_temperature = colname_air_temperature %in% colnames(met)
  solar_radiation = colname_solar_radiation %in% colnames(met)
  vapour_pressure = colname_vapour_pressure %in% colnames(met)
  relative_humidity = colname_relative_humidity %in% colnames(met)
  longwave_radiation = colname_longwave_radiation %in% colnames(met)
  cloud_cover = colname_cloud_cover %in% colnames(met)
  # Availability of precipitation data only used for snow module
  precipitation = colname_precipitation %in% colnames(met)
  snowfall = colname_snow %in% colnames(met)

  if(!is.null(lhc_file)){
    params <- read.csv(lhc_file)
    sub <- params[which(params[[metric]] < 2),]
    wind_factor <- mean(sub$wind_factor)
    swr_factor <- mean(sub$swr_factor)
    lw_factor <- mean(sub$lw_factor[sub$model %in% c('GLM', 'Simstrat')])

    message('Applying scaling factors:\nwind factor: ', signif(wind_factor,3), '\nswr factor: ', signif(swr_factor,3), '\nlw factor: ', signif(lw_factor,3))

    met$Ten_Meter_Elevation_Wind_Speed_meterPerSecond <- met$Ten_Meter_Elevation_Wind_Speed_meterPerSecond * wind_factor
    met$Shortwave_Radiation_Downwelling_wattPerMeterSquared <- met$Shortwave_Radiation_Downwelling_wattPerMeterSquared * swr_factor
    met$Longwave_Radiation_Downwelling_wattPerMeterSquared * lw_factor

  }

  # Met output file name
  met_outfile <- 'meteo_file.dat'

  # FLake
  #####
  if('FLake' %in% model){

    fla_met <- format_met(met = met, model = 'FLake', daily = daily, config_file = config_file)

    # Write to file
    write.table(fla_met, file.path(folder, 'FLake', met_outfile), sep = '\t', quote = FALSE, col.names = FALSE, row.names = FALSE)

    # Input values to nml
    nml_file <- list.files(file.path(folder, 'FLake'))[grep('nml', list.files(file.path(folder, 'FLake')))]
    nml_file <- file.path(folder, 'FLake', nml_file)

    input_nml(nml_file, 'SIMULATION_PARAMS', 'time_step_number', nrow(fla_met))
    input_nml(nml_file, 'METEO', 'meteofile', paste0("'",met_outfile,"'"))

    message('FLake: Created file ', file.path(folder,"FLake", met_outfile))


  }

  # GLM
  #####
  if('GLM' %in% model){
    glm_met <- format_met(met = met, model = 'GLM')

    # Write to file
    write.csv(glm_met, file.path('GLM', 'meteo_file.csv'), row.names = FALSE, quote = FALSE)

    if("LongWave" %in% colnames(glm_met)){
      lw_type = 'LW_IN'
    }else{
      lw_type = 'LW_IN' ### Needs to be developed catch if no LW
    }

    #
    # Note Jorrit 2019-12-14: : Why is this here? This should be defined in export_config. Removed setting start and stop in nml_list
    # start = glm_met[1,1]
    # stop = glm_met[nrow(glm_met),1]
    # # stop = '1980-01-01 00:00:00' # Added just for beta testing

    # Input to nml file
    nml_path <- file.path(folder, get_yaml_value(config_file, "config_files", "glm_config"))
    nml <- glmtools::read_nml(nml_path)

    nml_list <- list('subdaily' = subdaily, 'lw_type' = lw_type, 'meteo_fl' = 'meteo_file.csv')
    nml <- glmtools::set_nml(nml, arg_list = nml_list)

    glmtools::write_nml(nml, nml_path)
    message('GLM: Created file ', file.path(folder,"GLM", 'meteo_file.csv'))


  }

  ## GOTM
  if('GOTM' %in% model){

    yaml = file.path(folder,get_yaml_value(config_file, "config_files", "gotm_config"))

    met_outfile <- 'meteo_file.dat'

    met_outfpath <- file.path(folder, 'GOTM', met_outfile)
    met_got <- format_met(met, model = 'GOTM', daily = daily, config_file = config_file)

    write.table(met_got, met_outfpath, quote = FALSE, row.names = FALSE, sep = '\t', col.names = TRUE)


    # Format gotm.yaml file
    ## Set gotm.yaml met config - helper function
    set_met_config_yaml(met = met_outfpath, yaml_file = yaml)

    message('GOTM: Created file ', file.path(folder,"GOTM", met_outfile))


  }

  ## Simstrat
  if('Simstrat' %in% model){
    met_outfile <- 'meteo_file.dat'
    par_file <- file.path(folder, get_yaml_value(config_file, "config_files", "simstrat_config"))

    met_sim <- format_met(met = met, model = 'Simstrat', par_file = par_file)

    ### Write the table in the present working directory
    write.table(met_sim,file = file.path(folder,"Simstrat", met_outfile),sep = "\t",quote = F,row.names = F)
    input_json(file = par_file, label = 'Input', key = 'Forcing', '"meteo_file.dat"')

    message('Simstrat: Created file ', file.path(folder,"Simstrat", met_outfile))
  }

  # Set the timezone back to the original
  Sys.setenv(TZ=original_tz)


}

#' Export LakeEnsemblR standardized input to model specific driver format
#'@description
#'Export driver files for each model
#'
#' @name export_drivers
#' @param model vector; model to export driving data. Options include c('GOTM', 'GLM', 'Simstrat', 'FLake')
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param meteo_file filepath; to met file which is in the standardised LakeEnsemblR format.
#' 
#' @example 
#' export_meteo(model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#' 
#' @export


export_meteo <- function(model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file, folder = '.'){
  
  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz = Sys.getenv("tz")
  Sys.setenv(tz="GMT")
  
  
  ### Import data
  # I'd prefer to use a function that can read both comma and tab delimited. data.table::fread does this, but then it's data.table
  met = read.csv(file.path(folder,meteo_file), stringsAsFactors = F)
  met[,1] <- as.POSIXct(met[,1])
  # Check time step
  tstep <- diff(as.numeric(met[,1]))
  
  ### Naming conventions standard input
  # Depending on the setup of the standard config file, we can omit reading exact titles and read column numbers
  colname_time = "datetime"
  colname_wind_speed = "Ten_Meter_Elevation_Wind_Speed_meterPerSecond"
  colname_wind_direction = "Ten_Meter_Elevation_Wind_Direction_degree"
  colname_air_temperature = "Air_Temperature_celsius"
  colname_dewpoint_temperature = "Dewpoint_Temperature_celsius"
  colname_relative_humidity = "Relative_Humidity_percent"
  colname_solar_radiation = "Shortwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_longwave_radiation = "Longwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_surface_pressure = "Surface_Level_Barometric_Pressure_pascal"
  colname_precipitation = "Precipitation_meterPerSecond"
  colname_snow = "Snowfall_meterPerDay"
  colname_vapour_pressure = "Vapor_Pressure_milliBar"
  colname_cloud_cover = "Cloud_Cover_decimalFraction"
  
  ### Check what met data is available, as this determines what model forcing option to use (in the simstrat config file)
  datetime = colname_time %in% colnames(met)
  wind_speed = colname_wind_speed %in% colnames(met)
  wind_direction = colname_wind_direction %in% colnames(met)
  air_temperature = colname_air_temperature %in% colnames(met)
  solar_radiation = colname_solar_radiation %in% colnames(met)
  vapour_pressure = colname_vapour_pressure %in% colnames(met)
  relative_humidity = colname_relative_humidity %in% colnames(met)
  longwave_radiation = colname_longwave_radiation %in% colnames(met)
  cloud_cover = colname_cloud_cover %in% colnames(met)
  # Availability of precipitation data only used for snow module
  precipitation = colname_precipitation %in% colnames(met)
  snowfall = colname_snow %in% colnames(met)
  
  # Met output file name
  met_outfile <- 'meteo_file.dat'
  
  # FLake
  #####
  if('FLake' %in% model){
    fla_met <- met
    # Is data daily? - For cloud cover calculation
    if(sum(tstep != 86400) > 0){
      daily = FALSE
    }else{
      daily = TRUE
    }
    
    # Humidity
    if(!vapour_pressure & relative_humidity){
      # Calculate vapour pressure as: relhum * saturated vapour pressure
      # Used formula for saturated vapour pressure from: 
      # Woolway, R. I., Jones, I. D., Hamilton, D. P., Maberly, S. C., Muraoka, K., Read, J. S., . . . Winslow, L. A. (2015). 
      # Automated calculation of surface energy fluxes with high-frequency lake buoy data. 
      # Environmental Modelling & Software, 70, 191-198. 
      
      fla_met[[colname_vapour_pressure]]=fla_met[[colname_relative_humidity]]/100 * 6.11 * exp(17.27 * fla_met[[colname_air_temperature]] / (237.3 + fla_met[[colname_air_temperature]]))
      
    }
    if(!cloud_cover){
      
      fla_met[[colname_cloud_cover]] =  gotmtools::calc_cc(date = fla_met$datetime, airt = fla_met$Air_Temperature_celsius, relh = fla_met$Relative_Humidity_percent, swr = fla_met$Shortwave_Radiation_Downwelling_wattPerMeterSquared, lat = lat, long = lon,
                                                           elev = 14, # Needs to be added dynamically
                                                           daily = daily)
      
    }
    fla_met$index <- 1:nrow(fla_met)
    
    # Re-organise
    fla_met <- fla_met[,c('index','Shortwave_Radiation_Downwelling_wattPerMeterSquared','Air_Temperature_celsius', "Vapor_Pressure_milliBar", "Ten_Meter_Elevation_Wind_Speed_meterPerSecond", "Cloud_Cover_decimalFraction", "datetime")]
    fla_met$datetime <- format(fla_met$datetime, format = '%Y-%m-%d %H:%M:%S')
    colnames(fla_met)[1] <- paste0('!', colnames(fla_met)[1])
    
    # Write to file
    write.table(fla_met, file.path(folder, 'FLake', met_outfile), sep = '\t', quote = FALSE, col.names = FALSE, row.names = FALSE)
    
    # Input values to nml
    nml_file <- list.files(file.path(folder, 'FLake'))[grep('nml', list.files(file.path(folder, 'FLake')))]
    nml_file <- file.path(folder, 'FLake', nml_file)
    
    input_nml(nml_file, 'SIMULATION_PARAMS', 'time_step_number', nrow(fla_met))
    input_nml(nml_file, 'METEO', 'meteofile', paste0("'",met_outfile,"'"))
    input_nml(nml_file, 'METEO', 'outputfile', paste0("'output.dat'"))
    
    message('FLake: Created file ', file.path(folder,"FLake", met_outfile))
    
    
  }  
  
  # GLM
  #####
  if('GLM' %in% model){
    glm_met <- met
    
    # Is data daily? - For cloud cover calculation
    if(sum(tstep != 86400) > 0){
      subdaily = TRUE
    }else{
      subdaily = FALSE
    }
    
    # Convert units
    glm_met$Precipitation_meterPerDay <- glm_met$Precipitation_meterPerSecond * 86400
    
    # Subset data
    glm_met <- glm_met[,c('datetime','Shortwave_Radiation_Downwelling_wattPerMeterSquared', "Longwave_Radiation_Downwelling_wattPerMeterSquared", 'Air_Temperature_celsius', 'Relative_Humidity_percent', "Ten_Meter_Elevation_Wind_Speed_meterPerSecond", "Precipitation_meterPerDay", "Snowfall_meterPerDay")]
    
    colnames(glm_met) <- c('Date','ShortWave','LongWave','AirTemp','RelHum','WindSpeed','Rain','Snow')
    glm_met[,1] <- format(glm_met[,1], format = '%Y-%m-%d %H:%M:%S')
    
    # Write to file
    write.csv(glm_met, file.path('GLM', 'meteo_file.csv'), row.names = FALSE, quote = FALSE)
    
    if("LongWave" %in% colnames(glm_met)){
      lw_type = 'LW_IN'
    }else{
      lw_type = 'LW_IN' ### Needs to be developed catch if no LW
    }
    
    #
    start = glm_met[1,1]
    #stop = glm_met[nrow(glm_met),1]
    stop = '1980-01-01 00:00:00' # Added just for beta testing
    
    # Input to nml file
    nml <- glmtools::read_nml(file.path(folder,'GLM','glm3.nml'))
    
    nml_list <- list('start' = start, 'stop' = stop, 'subdaily' = daily, 'lw_type' = lw_type, 'meteo_fl' = 'meteo_file.csv')
    nml <- glmtools::set_nml(nml, arg_list = nml_list)
    
    glmtools::write_nml(nml, file.path(folder, 'GLM', 'glm3.nml'))
    message('GLM: Created file ', file.path(folder,"GLM", 'meteo_file.csv'))
    
    
  }
  
  ## GOTM
  if('GOTM' %in% model){
    met_got <- met
    yaml = file.path(folder,'GOTM', 'gotm.yaml')
    
    # Function to be added to gotmtools
    lat <- get_yaml_value(file = yaml, label = 'location', key = 'latitude')
    lon <- get_yaml_value(file = yaml, label = 'location', key = 'longitude')
    
    # Is data daily? - For cloud cover calculation
    if(sum(tstep != 86400) > 0){
      daily = FALSE
    }else{
      daily = TRUE
    }
    
    
    
    if(wind_direction){
      direction=270-met_got[[colname_wind_direction]] # Converting the wind direction to the "math" direction
      rads=direction/180*pi
      xcomp=met_got[[colname_wind_speed]]*cos(rads)
      ycomp=met_got[[colname_wind_speed]]*sin(rads)
      met_got$Uwind = xcomp
      met_got$Vwind = ycomp
    }else{
      met_got$Uwind_meterPerSecond = met_got[[colname_wind_speed]]
      met_got$Vwind_meterPerSecond = 0
    }
    
    if(!cloud_cover){
      # Function from gotmtools
      met_got$Cloud_Cover_decimalFraction <- gotmtools::calc_cc(date = met_got$datetime, airt = met_got$Air_Temperature_celsius, relh = met_got$Relative_Humidity_percent, swr = met_got$Shortwave_Radiation_Downwelling_wattPerMeterSquared, lat = lat, long = lon, 
                                                                elev = 14, # Needs to be dynamically added
                                                                daily = daily)
    }
    
    met_got <- met_got[,c('datetime', 'Uwind_meterPerSecond', 'Vwind_meterPerSecond', 'Surface_Level_Barometric_Pressure_pascal', 'Air_Temperature_celsius', 'Relative_Humidity_percent', 'Cloud_Cover_decimalFraction', 'Shortwave_Radiation_Downwelling_wattPerMeterSquared', 'Precipitation_meterPerSecond')]
    
    colnames(met_got)[1] <- paste0('!', colnames(met_got)[1])
    met_got[,1] <- format(met_got[,1], '%Y-%m-%d %H:%M:%S')
    
    #Reduce number of digits
    met_got[,-1] <- signif(met_got[,-1], digits = 8)
    
    write.table(met_got, file.path('GOTM', met_outfile), quote = FALSE, row.names = FALSE, sep = '\t', col.names = TRUE)
    
    # Format gotm.yaml file
    ## Set gotm.yaml met config
    ######
    #u10
    gotmtools::input_yaml(file = yaml, label = 'u10', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'u10', key = 'column', value = (which(colnames(met_got) == "Uwind_meterPerSecond")-1))
    gotmtools::input_yaml(file = yaml, label = 'u10', key = 'scale_factor', value = 1)
    #v10
    gotmtools::input_yaml(file = yaml, label = 'v10', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'v10', key = 'column', value = (which(colnames(met_got) == "Vwind_meterPerSecond")-1))
    gotmtools::input_yaml(file = yaml, label = 'v10', key = 'scale_factor', value = 1)
    #airp
    gotmtools::input_yaml(file = yaml, label = 'airp', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'airp', key = 'column', value = (which(colnames(met_got) == "Surface_Level_Barometric_Pressure_pascal" )-1))
    gotmtools::input_yaml(file = yaml, label = 'airp', key = 'scale_factor', value = 1)
    #airt
    gotmtools::input_yaml(file = yaml, label = 'airt', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'airt', key = 'column', value = (which(colnames(met_got) == "Air_Temperature_celsius")-1))
    gotmtools::input_yaml(file = yaml, label = 'airt', key = 'scale_factor', value = 1)
    #cloud
    gotmtools::input_yaml(file = yaml, label = 'cloud', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'cloud', key = 'column', value = (which(colnames(met_got) == "Cloud_Cover_decimalFraction" )-1))
    gotmtools::input_yaml(file = yaml, label = 'cloud', key = 'scale_factor', value = 1)
    #swr
    gotmtools::input_yaml(file = yaml, label = 'swr', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'swr', key = 'column', value = (which(colnames(met_got) == "Shortwave_Radiation_Downwelling_wattPerMeterSquared")-1))
    gotmtools::input_yaml(file = yaml, label = 'swr', key = 'scale_factor', value = 1)
    #precip
    gotmtools::input_yaml(file = yaml, label = 'precip', key = 'file', value = met_outfile)
    gotmtools::input_yaml(file = yaml, label = 'precip', key = 'column', value = (which(colnames(met_got) == "Precipitation_meterPerSecond")-1))
    gotmtools::input_yaml(file = yaml, label = 'precip', key = 'scale_factor', value = 1)
    if("Relative_Humidity_percent" %in% colnames(met_got)){
      #hum
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'file', value = met_outfile)
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'column', value = (which(colnames(met_got) == "Relative_Humidity_percent")-1))
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'type', value = 1) #1=relative humidity (%), 2=wet-bulb temperature, 3=dew point temperature, 4=specific humidity (kg/kg)
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'scale_factor', value = 1)
    }
    if("Dewpoint_Temperature_celsius" %in% colnames(met_got)){
      #hum
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'file', value = met_outfile)
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'column', value = (which(colnames(met_got) == "Dewpoint_Temperature_celsius")-1))
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'type', value = 3) #1=relative humidity (%), 2=wet-bulb temperature, 3=dew point temperature, 4=specific humidity (kg/kg)
      gotmtools::input_yaml(file = yaml, label = 'hum', key = 'scale_factor', value = 1)
    }
    
    # Set start/stop date - optional could be removed?
    start <- met_got[1,1]
    # stop <- met_got[nrow(met_got),1]
    stop = '1980-01-01 00:00:00' # Added just for beta testing
    gotmtools::input_yaml(file = yaml, label = 'time', key = 'start', value = start)
    gotmtools::input_yaml(file = yaml, label = 'time', key = 'stop', value = stop)
    
    message('GOTM: Created file ', file.path(folder,"GOTM", met_outfile))
    
    
  }
  
  ## Simstrat
  if('Simstrat' %in% model){
    fils <- list.files('Simstrat/')
    par_file <- file.path('Simstrat', fils[grep('par', fils)])
    met_sim <- met
    
    # Required input file changes depending on the forcing mode in the config file
    # Ideally; read from Simstrat par-file, now hard-coded
    if(!is.null(par_file)){
      par_text = readLines(par_file, warn = F)
      
      ind_label=grep("ModelConfig",par_text)
      ind_key = grep("Forcing", par_text)
      
      ind_key = ind_key[ind_key > ind_label]
      ind_label = ind_label[ind_key > ind_label]
      ind_map <- ind_key[which.min(ind_key - ind_label)]
      
      spl1 <- strsplit(par_text[ind_map], c("!"))[[1]]
      spl2 <- gsub("\"","",strsplit(spl1[1], ": ")[[1]][2])
      forcing_mode <- strsplit(spl2[1], ", ")[[1]][1]
    }else{
      forcing_mode = "5"
    }
    # Optionally, we can check the availability of data to set the forcing mode (5 possible, no? Then 3, then 2, then 1)
    
    
    ### Pre-processing
    # Time
    if(datetime){
      # Time in simstrat is in decimal days since a defined start year
      # Read from par_file. If not possible, hard-coded to 1861 (based on ISIMIP simulations)
      if(!is.null(par_file)){
        par_text = readLines(par_file, warn = F)
        
        ind_label=grep("Simulation",par_text)
        ind_key = grep("Start year", par_text)
        
        ind_key = ind_key[ind_key > ind_label]
        ind_label = ind_label[ind_key > ind_label]
        ind_map <- ind_key[which.min(ind_key - ind_label)]
        
        spl1 <- strsplit(par_text[ind_map], c("!"))[[1]]
        spl2 <- gsub("\"","",strsplit(spl1[1], ": ")[[1]][2])
        start_year <- strsplit(spl2[1], ", ")[[1]][1]
      }else{
        start_year = "1861"
      }
      met_sim$datetime = as.numeric(difftime(met_sim$datetime,as.POSIXct(paste0(start_year,"-01-01")),units = "days"))
    }else{
      stop("Cannot find \"datetime\" column in the input file. Without this column, the model cannot run")
    }
    
    # Wind
    # If wind direction is provided, U and V wind components are calculated. If not, V wind is set to 0
    if(wind_direction){
      direction=270-met_sim[[colname_wind_direction]] # Converting the wind direction to the "math" direction
      rads=direction/180*pi
      xcomp=met_sim[[colname_wind_speed]]*cos(rads)
      ycomp=met_sim[[colname_wind_speed]]*sin(rads)
      met_sim$Uwind = xcomp
      met_sim$Vwind = ycomp
    }else{
      met_sim$Uwind_meterPerSecond = met_sim[[colname_wind_speed]]
      met_sim$Vwind_meterPerSecond = 0
    }
    
    # Humidity
    if(!vapour_pressure & relative_humidity){
      # Calculate vapour pressure as: relhum * saturated vapour pressure
      # Used formula for saturated vapour pressure from: 
      # Woolway, R. I., Jones, I. D., Hamilton, D. P., Maberly, S. C., Muraoka, K., Read, J. S., . . . Winslow, L. A. (2015). 
      # Automated calculation of surface energy fluxes with high-frequency lake buoy data. 
      # Environmental Modelling & Software, 70, 191-198. 
      
      met_sim[[colname_vapour_pressure]]=met_sim[[colname_relative_humidity]]/100 * 6.11 * exp(17.27 * met_sim[[colname_air_temperature]] / (237.3 + met_sim[[colname_air_temperature]]))
      
    }
    
    # If snow_module is true, there needs to be a precipitation (or snowfall) columnn. 
    # Ideally; read from Simstrat par-file, now hard-coded
    if(!is.null(par_file)){
      par_text = readLines(par_file, warn = F)
      
      ind_label=grep("ModelConfig",par_text)
      ind_key = grep("SnowModel", par_text)
      
      ind_key = ind_key[ind_key > ind_label]
      ind_label = ind_label[ind_key > ind_label]
      ind_map <- ind_key[which.min(ind_key - ind_label)]
      
      spl1 <- strsplit(par_text[ind_map], c("!"))[[1]]
      spl2 <- gsub("\"","",strsplit(spl1[1], ": ")[[1]][2])
      snow_module <- strsplit(spl2[1], " ")[[1]][1]=="1"
    }else{
      snow_module = T
    }
    # Optionally, if there is no precipitation/snowfall column, we can set the snow_module to FALSE
    
    if(snow_module & !(precipitation | snowfall)){
      stop("There is no precipitation data and the snow_module is set to TRUE.")
    }
    
    
    # Precipitation
    # Precipitation needs to be in m h-1: 1 m s-1 = 3600 m h-1, or 1 m d-1 = 1/24 m h-1
    if(precipitation){
      met_sim$`Precipitation_meterPerHour`=met_sim[[colname_precipitation]]*3600
    }else if(snowfall){
      met_sim$`Precipitation_meterPerHour`=met_sim[[colname_snow]]/24
    }
    
    
    
    
    ### Build simstrat_forcing file
    # Boolean to see if there is enough data to write the meteo file
    enoughData=T
    
    
    # Now build the simstrat forcing file, based on the forcing_mode. If data is not available, an error message is displayed
    if(forcing_mode == "5"){
      if(!(wind_speed & air_temperature & solar_radiation & (vapour_pressure | relative_humidity) & longwave_radiation)){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond", 
                                   colname_air_temperature, colname_solar_radiation, colname_vapour_pressure,
                                   colname_longwave_radiation)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }else if(forcing_mode == "4"){
      # Forcing mode 4 requires one column with "heat flux" input. LakeEnsemblR does not yet have functionality for this option
      enoughData = F
    }else if(forcing_mode == "3"){
      if(!(wind_speed & air_temperature & solar_radiation & (vapour_pressure | relative_humidity) & cloud_cover)){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond", 
                                   colname_air_temperature, colname_solar_radiation, colname_vapour_pressure,
                                   colname_cloud_cover)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }else if(forcing_mode == "2"){
      if(!(wind_speed & air_temperature & solar_radiation & (vapour_pressure | relative_humidity))){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond", 
                                   colname_air_temperature, colname_solar_radiation, colname_vapour_pressure)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }else if(forcing_mode == "1"){
      if(!(wind_speed & air_temperature & solar_radiation)){
        enoughData = F
      }else{
        simstrat_forcing = met_sim[, c(colname_time, "Uwind_meterPerSecond", "Vwind_meterPerSecond", 
                                   colname_air_temperature, colname_solar_radiation)]
        if(snow_module){
          simstrat_forcing[["Precipitation_meterPerHour"]] = met_sim[["Precipitation_meterPerHour"]]
        }
      }
    }
    
    if(!enoughData){stop(paste("There is no data to run the model in forcing mode",forcing_mode))}
    
    ### Write the table in the present working directory
    write.table(simstrat_forcing,file = file.path(folder,"Simstrat", met_outfile),sep = "\t",quote = F,row.names = F)
    input_json(file = par_file, label = 'Input', key = 'Forcing', '"meteo_file.dat"')
    
    message('Simstrat: Created file ', file.path(folder,"Simstrat", met_outfile))
  }
  
  # Set the timezone back to the original
  Sys.setenv(tz=original_tz)
  
  
}
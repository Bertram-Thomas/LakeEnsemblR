#' Run Latin hypercube sampling
#'@description
#'Run lake models using Latin hypercube sampling for model parameters.
#'
#' @name run_MCMC
#' @param parRange dataframe; the range (min, max) of the parameters, a data.frame with one row for each parameter, and two columns with the minimum (1st) and maximum (2nd) column.
#' @param num integer; the number of random parameter sets to generate. If param file is provided num = number of parameters in that file.
#' @param obs_file filepath; to LakeEnsemblR standardised observed water temperature profile data. If included adds observed data to netCDF and list if they are set to TRUE. Defaults to NULL.
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include c('GOTM', 'GLM', 'Simstrat', 'FLake')
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param meteo_file filepath; to met file which is in the standardised LakeEnsemblR format.
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#'
#' @examples
#' \dontrun{
#'pars <- c('wind_factor', 'swr_factor', 'lw_factor')
#'mat <- matrix(data = c(0.5,2,0.5,1.5,0.5,1.5), nrow = 3, byrow = T)
#'df <- as.data.frame(mat)
#'rownames(df) <- pars
#'run_LHC(parRange = parRange, num = 100, obs_file = 'LakeEnsemblR_wtemp_profile_standard.csv', config_file = 'Feeagh_master_config.yaml', model = 'FLake', meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#' }
#'pars <- c('wind_factor', 'swr_factor', 'lw_factor')
#'mat <- matrix(data = c(0.5,2,0.5,1.5,0.5,1.5), nrow = 3, byrow = T)
#'df <- as.data.frame(mat)
#'rownames(df) <- pars
#'run_LHC(parRange = parRange, num = 100, obs_file = 'LakeEnsemblR_wtemp_profile_standard.csv', config_file = 'Feeagh_master_config.yaml', model = 'FLake', meteo_file = 'LakeEnsemblR_meteo_standard.csv')
#'@importFrom FME Latinhyper
#'@importFrom gotmtools get_yaml_value calc_cc input_nml sum_stat input_yaml get_vari
#'@importFrom glmtools get_nml_value
#'@importFrom reshape2 dcast
#'@importFrom FLakeR run_flake
#'@importFrom GLM3r run_glm
#'@importFrom GOTMr run_gotm
#'@importFrom SimstratR run_simstrat
#'@importFrom lubridate round_date seconds_to_period
#'
#' @export

library(gotmtools)
library(reshape2)

## RC
masterConfigFile <- 'Feeagh_master_config.yaml'

pars <- c('wind_factor', 'swr_factor', 'lw_factor')
mat <- matrix(data = c(0.5,2,0.5,1.5,0.5,1.5), nrow = 3, byrow = T)
df <- as.data.frame(mat)
rownames(df) <- pars
df$method = c('uniform','uniform','uniform')
df # Print parameter ranges

# Run Latin_hypercube sample
parRange = df
num = 300
obs_file = 'LakeEnsemblR_wtemp_profile_standard.csv'
param_file = NULL
config_file = 'Feeagh_master_config.yaml'
model = c('GLM')
meteo_file = 'LakeEnsemblR_meteo_standard.csv'
setwd('example/feeagh') 
folder = '.'

run_MCMC <- function(parRange, num = NULL, obs_file, config_file, model = c('GOTM', 'GLM', 'Simstrat', 'FLake'), meteo_file, folder = '.'){

  # It's advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz = Sys.getenv("TZ")
  Sys.setenv(TZ="GMT")

  obs <- read.csv(file.path(folder, obs_file), stringsAsFactors = FALSE)
  obs_deps <- unique(obs$Depth_meter)

  # change data format from long to wide
  obs_out <- dcast(obs, datetime ~ Depth_meter, value.var = 'Water_Temperature_celsius')
  str_depths <- colnames(obs_out)[2:ncol(obs_out)]
  colnames(obs_out) <- c('datetime',paste('wtr_',str_depths, sep=""))
  obs_out$datetime <- as.POSIXct(obs_out$datetime)

  # get lat and lon - currently hack getting from GOTM but maybe could be in global config file?
  yaml = file.path(folder,config_file)

  # Function to be added to gotmtools
  lat <- get_yaml_value(file = yaml, label = 'location', key = 'latitude')
  lon <- get_yaml_value(file = yaml, label = 'location', key = 'longitude')
  depth <- get_yaml_value(file = yaml, label = 'location', key = 'depth')
  start <- get_yaml_value(file = yaml, label = 'time', key = 'start')
  stop <- get_yaml_value(file = yaml, label = 'location', key = 'stop')

  obs <- obs[obs[,1] >= start & obs[,1] < stop,]

  # Which hemisphere?
  if(lat > 0){
    NH = TRUE
  }else{
    NH = FALSE
  }


  ### Import data
  # I'd prefer to use a function that can read both comma and tab delimited. data.table::fread does this, but then it's data.table
  message('Loading met data...')
  met = read.csv(file.path(folder,meteo_file), stringsAsFactors = F)
  met[,1] <- as.POSIXct(met[,1])
  # Check time step
  tstep <- diff(as.numeric(met[,1]))

  if((mean(tstep) - 86400)/86400 < -0.05){
    daily = FALSE
    subdaily = TRUE
  } else {
    daily = TRUE
    subdaily = FALSE
  }


  ### Naming conventions standard input
  # Depending on the setup of the standard config file, we can omit reading exact titles and read column numbers
  colname_time = "datetime"
  colname_wind_speed = "Ten_Meter_Elevation_Wind_Speed_meterPerSecond"
  colname_wind_direction = "Ten_Meter_Elevation_Wind_Direction_degree"
  colname_air_temperature = "Air_Temperature_celsius"
  colname_dewpoint_temperature = "Dewpoint_Temperature_celsius"
  colname_relative_humidity = "Relative_Humidity_percent"
  colname_solar_radiation = "Shortwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_longwave_radiation = "Longwave_Radiation_Downwelling_wattPerMeterSquared"
  colname_surface_pressure = "Surface_Level_Barometric_Pressure_pascal"
  colname_precipitation = "Precipitation_meterPerSecond"
  colname_snow = "Snowfall_meterPerDay"
  colname_vapour_pressure = "Vapor_Pressure_milliBar"
  colname_cloud_cover = "Cloud_Cover_decimalFraction"

  ### Check what met data is available, as this determines what model forcing option to use (in the simstrat config file)
  datetime = colname_time %in% colnames(met)
  wind_speed = colname_wind_speed %in% colnames(met)
  wind_direction = colname_wind_direction %in% colnames(met)
  air_temperature = colname_air_temperature %in% colnames(met)
  solar_radiation = colname_solar_radiation %in% colnames(met)
  vapour_pressure = colname_vapour_pressure %in% colnames(met)
  relative_humidity = colname_relative_humidity %in% colnames(met)
  longwave_radiation = colname_longwave_radiation %in% colnames(met)
  cloud_cover = colname_cloud_cover %in% colnames(met)
  # Availability of precipitation data only used for snow module
  precipitation = colname_precipitation %in% colnames(met)
  snowfall = colname_snow %in% colnames(met)

  ### RC 
  unique(obs$Depth_meter)
  data = obs$Water_Temperature_celsius
  data = subset(obs, Depth_meter %in% c(0.9,2.5,5,8,11))$Water_Temperature_celsius
  data = subset(obs, Depth_meter %in% c(14,16.18,20,22,27,32,42))$Water_Temperature_celsius
  
  plot(density(data))
  plot(density(log10(data)))
  plot(density(sqrt(data)))
  plot(density(1/data))
  plot(density(1/2*log(sinh(3+2*data))))

  all_pars <- NULL
  all_sa <- NULL


  # GLM
  #####
  if('GLM' %in% model){
    glm_met <- met

    # Convert units
    glm_met$Precipitation_meterPerDay <- glm_met$Precipitation_meterPerSecond * 86400

    # Subset data
    glm_met <- glm_met[,c('datetime','Shortwave_Radiation_Downwelling_wattPerMeterSquared', "Longwave_Radiation_Downwelling_wattPerMeterSquared", 'Air_Temperature_celsius', 'Relative_Humidity_percent', "Ten_Meter_Elevation_Wind_Speed_meterPerSecond", "Precipitation_meterPerDay", "Snowfall_meterPerDay")]

    colnames(glm_met) <- c('Date','ShortWave','LongWave','AirTemp','RelHum','WindSpeed','Rain','Snow')
    glm_met[,1] <- format(glm_met[,1], format = '%Y-%m-%d %H:%M:%S')

    if("LongWave" %in% colnames(glm_met)){
      lw_type = 'LW_IN'
    }else{
      lw_type = 'LW_IN' ### Needs to be developed catch if no LW
    }

    # Input to nml file
    nml_path <- file.path(folder, get_yaml_value(config_file, "config_files", "glm_config"))
    nml <- glmtools::read_nml(nml_path)

    nml_list <- list('subdaily' = subdaily, 'lw_type' = lw_type, 'meteo_fl' = 'temp_meteo_file.csv')
    nml <- glmtools::set_nml(nml, arg_list = nml_list)

    glmtools::write_nml(nml, nml_path)

    # Input values to nml
    nml_file <- file.path(folder, 'GLM', 'glm3.nml')

    input_nml(nml_file, 'meteorology', 'meteo_fl', paste0("'",'temp_meteo_file.csv',"'"))

    # Get depths for comparison
    depths <- obs_deps
    
    params = as.data.frame(matrix(NA, ncol = nrow(parRange), nrow=1)) # initial parameter guesses
    for (ii in 1:nrow(parRange)){
      var.name = rownames(parRange)
      if (parRange$method[ii] == 'uniform'){
        params[,ii] = runif(1, parRange$V1[ii], parRange$V2[ii]) 
      } else if (parRange$method[ii] == 'normal') {
        params[,ii] = rnorm(1, parRange$V1[ii], parRange$V2[ii])
      }
    }
    colnames(params) = c(var.name)
    params$par_id = seq(1,nrow(params),1)
    
    step_param <- function(curPar, parRange){
      ready = TRUE
      while (ready){
        df = curPar[-length(curPar)] + (runif(1,1,2) *runif(3,-1,1)/(parRange$V2-parRange$V1)/runif(1,1,5))
        if (all(df > parRange$V1) && all(df < parRange$V2)){
          ready = FALSE
        }
      }
      return(df)
    }
    
    glm_met2 <- glm_met
    glm_met2$WindSpeed <- glm_met2$WindSpeed * params$wind_factor[1]
    glm_met2$ShortWave <- glm_met2$ShortWave * params$swr_factor[1]
    glm_met2$LongWave <- glm_met2$LongWave * params$lw_factor[1]
    
    # Write to file
    write.csv(glm_met2, file.path(folder, 'GLM', 'temp_meteo_file.csv'), quote = FALSE, row.names = FALSE)
    run_glm(sim_folder = file.path(folder, 'GLM'))
    
    # Extract output
    # Add in obs depths which are not in depths and less than mean depth
    
    # Extract output
    glm_out <- glmtools::get_var(file = file.path(folder, 'GLM', 'output', 'output.nc'), var_name = 'temp', reference = 'surface', z_out = depths)
    
    glm_sa <- glmtools::get_var(file = file.path(folder, 'GLM', 'output', 'output.nc'), var_name = 'temp', reference = 'surface', z_out = c(0, depth-1))
    
    
    glm_out <- reshape2::melt(glm_out, id.vars = 1)
    glm_out[,2] <- as.character(glm_out[,2])
    glm_out[,2] <- as.numeric(gsub('temp_','',glm_out[,2]))
    colnames(glm_out) <- c('datetime','Depth_meter','Water_Temperature_celsius')
    
    stats <- sum_stat(glm_out, obs, depth = TRUE)
    stats$par_id <- params$par_id[1]
    new_stats = stats
    # Calculate stats for Sensitivity Analysis
    # sa_res <- analyse_strat(Ts = glm_sa[,2], Tb = glm_sa[,ncol(glm_sa)], dates = glm_sa[,1], NH = NH)
    
    # sa_res$par_id <- params$par_id[i]
    
      out_stats <- new_stats
      # sa_stats <- sa_res
      
      cost_prior = stats$MAE
num=1000
    for(i in 2:(num)){
      
      params_current = step_param(curPar = params[(i-1),], parRange)
      glm_met2 <- glm_met
      glm_met2$WindSpeed <- glm_met2$WindSpeed * params_current$wind_factor
      glm_met2$ShortWave <- glm_met2$ShortWave * params_current$swr_factor
      glm_met2$LongWave <- glm_met2$LongWave * params_current$lw_factor

      # Write to file
      write.csv(glm_met2, file.path(folder, 'GLM', 'temp_meteo_file.csv'), quote = FALSE, row.names = FALSE)
      run_glm(sim_folder = file.path(folder, 'GLM'))

      # Extract output
      # Add in obs depths which are not in depths and less than mean depth

      # Extract output
      glm_out <- glmtools::get_var(file = file.path(folder, 'GLM', 'output', 'output.nc'), var_name = 'temp', reference = 'surface', z_out = depths)

      glm_sa <- glmtools::get_var(file = file.path(folder, 'GLM', 'output', 'output.nc'), var_name = 'temp', reference = 'surface', z_out = c(0, depth-1))


      glm_out <- reshape2::melt(glm_out, id.vars = 1)
      glm_out[,2] <- as.character(glm_out[,2])
      glm_out[,2] <- as.numeric(gsub('temp_','',glm_out[,2]))
      colnames(glm_out) <- c('datetime','Depth_meter','Water_Temperature_celsius')

      stats <- sum_stat(glm_out, obs, depth = TRUE)
    
      # Calculate stats for Sensitivity Analysis
      # sa_res <- analyse_strat(Ts = glm_sa[,2], Tb = glm_sa[,ncol(glm_sa)], dates = glm_sa[,1], NH = NH)
      # sa_res$par_id <- params$par_id[i]
      
      cost_current = stats$MAE
      
      if (runif(1) < exp(-(cost_current-cost_prior))){# (runif(1) < cost_prior/cost_current)
        params_current$par_id = max(params$par_id) +1
        params = rbind(params, params_current)
        cost_prior = cost_current
        new_stats = stats
        new_stats$par_id <- max(params$par_id) +1
        # new_sa_res = sa_res
      } else {
        params = rbind(params, params[i-1,])
      }

        out_stats <- rbind.data.frame(out_stats, new_stats)
        # sa_stats <- rbind.data.frame(sa_stats, new_sa_res)

      print(paste0('[',i,'/', num,']'))
    }

  idx = which(out_stats$NSE == max(out_stats$NSE))[1]
  out_stats[idx,]
  params[idx,]
  best.params = as.data.frame(t(params[idx,-c(ncol(params))]))
  colnames(best.params) = 'best'
  best.params$parameter = rownames(best.params)
  library(ggplot2)
  m.params <- reshape2::melt(params,id.vars= 'par_id')
  g0=ggplot(m.params, aes(x=par_id, value, col = variable))+
    geom_line() +
    theme_bw();g0
  g1=ggplot(m.params, aes(x=value, fill = variable))+
    geom_density(alpha=0.4) +
    # geom_vline(data=best.params, aes(xintercept=best, col =parameter),
               # linetype="dashed") +
    theme_bw();g1
  g2=ggplot(out_stats, aes(par_id, NSE)) +
    geom_line() +
    theme_bw();g2
  g3=ggplot(out_stats, aes(par_id, RMSE)) +
    geom_line() +
    theme_bw();g3
  g4=ggplot(out_stats, aes(NSE, RMSE, col =MAE)) +
    geom_point() +
    scale_x_reverse() +
    theme_bw();g4
  library(patchwork)
  p = g0 / g1 / (g2+g3+g4);p
  
  ggsave(file='MCMC.png', p, dpi = 300, width = 316, height=216, units='mm')
  


    write.csv(out_stats, file.path(folder, 'GLM', 'output', paste0('MCMC_calibration_results_','p',num, '_', format(Sys.time(), format = '%Y%m%d%H%M'), '.csv')), quote = FALSE, row.names = FALSE)

    write.csv(params, file.path(folder, 'GLM', 'output', paste0('MCMC_params_results_','p',num, '_', format(Sys.time(), format = '%Y%m%d%H%M'), '.csv')), quote = FALSE, row.names = FALSE)


    out_stats$model <- 'GLM'
    sa_stats$model <- 'GLM'

    if(is.null(all_pars)){
      all_pars <- out_stats
    }else{
      all_pars <- rbind.data.frame(all_pars, out_stats)
    }

    if(is.null(all_sa)){
      all_sa <- sa_stats
    }else{
      all_sa <- rbind.data.frame(all_sa, sa_stats)
    }

    message('GLM: Finished doing a pseudo MCMC, took me long enough')

  }




  dir.create(file.path(folder,'output'), showWarnings = FALSE)

  write.csv(all_pars, file.path(folder,'output', paste0('LHC_calibration_results_','p',num, '_', format(Sys.time(), format = '%Y%m%d%H%M'), '.csv')), quote = FALSE, row.names = FALSE)

  write.csv(all_sa, file.path(folder,'output', paste0('LHC_sa_results_','p',num, '_', format(Sys.time(), format = '%Y%m%d%H%M'), '.csv')), quote = FALSE, row.names = FALSE)

}



#' Calibrate models
#' 
#' Use one of three methods to calibrate specified models.
#'
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param num integer; the number of random parameter sets to generate. If param file is provided
#' num = number of parameters in that file.
#' @param param_file filepath; to previously created parameter file set. If NULL creates a new
#' parameter set. Defaults to NULL
#' @param cmethod character; Method for calibration. Can be "LHC", "MCMC" or "". Defaults to "LHC"
#' @param obs_file filepath; to LakeEnsemblR standardised observed water temperature profile data.
#' If included adds observed data to netCDF and list if they are set to TRUE. Defaults to NULL.
#' @param config_file filepath; to LakeEnsemblr yaml master config file
#' @param model vector; model to export driving data. Options include c("GOTM", "GLM", "Simstrat",
#' "FLake")
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param folder filepath; to folder which contains the model folders generated by export_config()
#' @param spin_up numeric; Number of days to disregard as spin-up for analysis.
#' @param out_f character; name of the folder to store results into
#' @param qualfun function; function that calculates measure of fit from observed and simulated 
#'    variables, takes the two arguments Observed and Simulated
#' @param nout_fun integer; number of return values from qualfun
#' @param parallel Boolean; should the model calibration be parallelized
#' @param ... additional arguments passed to modFit or modMCMC. Only used when method is
#'    modFit or MCMC
#' @details Parallelization is done using the `parallel` package and `parLapply()`. The number of
#'    cores used is set to the number of available cores minus one.
#'
#' @examples
#' \dontrun{
#' 
#' config_file <- 'LakeEnsemblR.yaml'
#' 
#' cali_ensemble(config_file = config_file, num = 200, cmethod = "LCH",
#'              model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"))
#'              
#' resMCMC <- cali_ensemble(config_file = config_file, num = 200, cmethod = "MCMC",
#'                          model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"))
#'                
#' resMmodFit <- cali_ensemble(config_file = config_file, num = 200, cmethod = "modFit",
#'                             model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"),
#'                             method = "Nelder-Mead")                                           
#'              
#' }
#' @importFrom reshape2 dcast
#' @importFrom parallel detectCores
#' @importFrom parallel parLapply
#' @importFrom parallel clusterExport
#' @importFrom parallel makeCluster
#' @importFrom parallel clusterEvalQ
#' @importFrom FME Latinhyper
#' @importFrom FME modMCMC
#' @importFrom gotmtools get_yaml_value calc_cc input_nml sum_stat input_yaml get_vari
#' @importFrom glmtools get_nml_value
#' @importFrom reshape2 dcast
#' @importFrom FLakeR run_flake
#' @importFrom GLM3r run_glm
#' @importFrom GOTMr run_gotm
#' @importFrom SimstratR run_simstrat
#' @importFrom MyLakeR run_mylake
#' @importFrom lubridate round_date seconds_to_period
#' @importFrom configr read.config
#'
#' @export

cali_ensemble <- function(config_file, num = NULL, param_file = NULL, cmethod = "LHC",
                          qualfun = qual_fun, parallel = FALSE,
                          model = c("FLake", "GLM", "GOTM", "Simstrat", "MyLake"),
                          folder = ".", spin_up = NULL, out_f = "cali", nout_fun = 5, ...) {

##----------------- check inputs and set things up -------------------------------------------------  
  
  # check if method is one of the allowed
  if(!cmethod %in% c("modFit", "LHC", "MCMC")) {
    stop(paste0("Method ", cmethod, " not allowed. Use one of: modFit, LHC, or MCMC"))
  }
  
  # check model input
  model <- check_models(model)
  # check the master config file
  check_master_config(config_file, model)
  
  # It"s advisable to set timezone to GMT in order to avoid errors when reading time
  original_tz <- Sys.getenv("TZ")
  Sys.setenv(TZ = "GMT")
  tz <- "UTC"
  
  # Set working directory
  oldwd <- getwd()
  
  # this way if the function exits for any reason, success or failure, these are reset:
  on.exit({
    setwd(oldwd)
    Sys.setenv(TZ = original_tz)
  })
  
  
  # path to master config file
  yaml <- file.path(folder, config_file)
  # get setup parameter
  lat <- get_yaml_value(file = yaml, label = "location", key = "latitude")
  start <- get_yaml_value(file = yaml, label = "time", key = "start")
  stop <- get_yaml_value(file = yaml, label = "location", key = "stop")
  meteo_file <- get_yaml_value(file = yaml, label = "meteo", key = "file")
  obs_file <- get_yaml_value(file = yaml, label = "temperature", key = "file")
  time_unit <- get_yaml_value(config_file, "output", "time_unit")
  time_step <- get_yaml_value(config_file, "output", "time_step")
  cnfg_l <- lapply(model, function(m) get_yaml_value(config_file, "config_files", m))
  names(cnfg_l) <- model
  met_timestep <- get_meteo_time_step(file.path(folder,
                                                get_yaml_value(config_file, "meteo", "file")))
 
  # name for the output files
  if(is.null(param_file)) {
    outf_n <- paste0(cmethod, "_", format(Sys.time(), "%Y%m%d%H%M"))
  } else {
    outf_n <- gsub("_params_", "", basename(param_file))
  }
  
##----------------- read in observed data  ---------------------------------------------------------  
 
  # Create output time vector
  if(is.null(spin_up)){
    out_time <- seq.POSIXt(as.POSIXct(start, tz = tz), as.POSIXct(stop, tz = tz), by =
                             paste(time_step, time_unit))
  }else{
    start <- as.POSIXct(start, tz = tz) + spin_up * 24 * 60 * 60
    stop <- as.POSIXct(stop, tz = tz)
    out_time <- seq.POSIXt(as.POSIXct(start, tz = tz), as.POSIXct(stop, tz = tz), by =
                             paste(time_step, time_unit))
  }
  out_time <- data.frame(datetime = out_time)
  
  if(met_timestep == 86400){
    out_hour <- hour(start)
  }else{
    out_hour <- 0
  }
  
  # read in Observed data
  message("Loading observed wtemp data...")
  obs <- read.csv(file.path(folder, obs_file), stringsAsFactors = FALSE)
  obs$datetime <- as.POSIXct(obs$datetime, tz = tz)
  
  # Susbet to out_time
  obs <- obs[obs$datetime %in% out_time$datetime, ]
  
  obs_deps <- unique(obs$Depth_meter)
  
  # change data format from long to wide
  obs_out <- dcast(obs, datetime ~ Depth_meter, value.var = "Water_Temperature_celsius")
  str_depths <- colnames(obs_out)[2:ncol(obs_out)]
  colnames(obs_out) <- c("datetime", paste("wtr_", str_depths, sep = ""))
  obs_out$datetime <- as.POSIXct(obs_out$datetime)
  message("Finished!")
  
##---------------- read in  parameter initial values or create parameter sets ----------------------
  
  # if not existing create output file
  dir.create(file.path(folder, out_f), showWarnings = FALSE)
  # if cmethod == LHC sample parameter or read from provided file
  if(cmethod == "LHC") {
    if(is.null(param_file)) {
      param_file <- sample_LHC(config_file = config_file, num = num, method = "met",
                               folder = folder,
                               file.name = file.path(folder, out_f, paste0("pars_", outf_n))
                               )
    }
    params <- read.csv(param_file, stringsAsFactors = FALSE)
    num <- nrow(params)
  } else {
    ## else use initial values from master config file as starting values
    # load master config file
    configr_master_config <- configr::read.config(file.path(folder, config_file))
    # meteo parameter
    cal_section <- configr_master_config[["calibration"]][["met"]]
    params_met <- sapply(names(cal_section), function(n)cal_section[[n]]$initial)
    p_lower_met <- sapply(names(cal_section), function(n)cal_section[[n]]$lower)
    p_upper_met <- sapply(names(cal_section), function(n)cal_section[[n]]$upper)
    # get names of models for which parameter are given
    model_p <- model[model %in% names(configr_master_config[["calibration"]])]
    # model specific parameters
    cal_section <- lapply(model_p, function(m)configr_master_config[["calibration"]][[m]])
    names(cal_section) <- model_p
    params_mod <- lapply(model_p, function(m) {
                    sapply(names(cal_section[[m]]),
                           function(n) as.numeric(cal_section[[m]][[n]]$initial))})
    names(params_mod) <- model_p
    p_lower_mod <- lapply(model_p, function(m) {
      sapply(names(cal_section[[m]]),
             function(n) as.numeric(cal_section[[m]][[n]]$lower))})
    names(p_lower_mod) <- model_p
    p_upper_mod <- lapply(model_p, function(m) {
      sapply(names(cal_section[[m]]),
             function(n) as.numeric(cal_section[[m]][[n]]$upper))})
    names(p_upper_mod) <- model_p
  }

##--------- prepare models to be run ---------------------------------------------------------------  

  # prepare controll files of the models
  export_config(config_file = config_file, model = model, folder = folder)
  # prepare meteo files for the models
  export_meteo(config_file = config_file,model =  model,meteo_file =  meteo_file, folder = folder)
  # export initial conditions for each model
  export_init_cond(config_file = config_file, 
                   model = model,
                   print = TRUE)
  
##----------------- read in model meteo files ------------------------------------------------------
  
  ## read in meteo
  met_l <- lapply(model, function(m){
    met_name <- get_model_met_name(m, cnfg_l[[m]])
    ## list with long standard names
    l_names <- as.list(met_var_dic$standard_name)
    names(l_names) <- met_var_dic$short_name
    
    if(m == "MyLake") {
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t",
                        header = FALSE)
      colnames(met_m) <- c(l_names$time, l_names$swr, l_names$cc, l_names$airt, l_names$relh,
                           l_names$p_surf, l_names$wind_speed, l_names$precip)
    } else if (m == "GLM") {
      met_m <- read.table(file.path(folder, m, met_name), sep = ",", header = TRUE)
    } else if (m == "FLake") {
      # read in meteo file
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t",
                              header = FALSE)
      colnames(met_m) <- c("!Shortwave_Radiation_Downwelling_wattPerMeterSquared",
                           "Air_Temperature_celsius", "Vapor_Pressure_milliBar",
                           "Ten_Meter_Elevation_Wind_Speed_meterPerSecond",
                           "Cloud_Cover_decimalFraction", "datetime")
    } else if (m == "GOTM") {
      # read in meteo file
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t", header = TRUE)
      colnames(met_m)[1] <- "!datetime"
    } else if(m == "Simstrat") {
      # read in meteo file
      met_m <- read.table(file.path(folder, m, met_name), sep = "\t",
                                 header = TRUE)
      
    }
    return(met_m)
  })

  names(met_l) <- model

##------------------------- LCH calibration ----------------------------------------------------------

  if(parallel){
    ncores <- detectCores() -1
    clust <- makeCluster(ncores)
    clusterExport(clust, varlist = list("params", "model", "config_file", "met_l",
                                        "folder", "out_f", "cnfg_l", "obs_deps",
                                        "obs_out", "out_hour", "qualfun",
                                        "outf_n"),
                  envir = environment())
    clusterEvalQ(clust, library(LakeEnsemblR))
    if(cmethod == "LHC") {
      model_out <- setNames(
        parLapply(clust, model, function(mod_name) LHC_model(pars = params,
                                                   type = rep("met", (ncol(params)-1)),
                                                   model = mod_name, var = "temp",
                                                   config_file = config_file,
                                                   met = met_l[[mod_name]], folder = folder,
                                                   out_f = out_f, config_f = cnfg_l[[mod_name]],
                                                   obs_deps = obs_deps, obs_out = obs_out,
                                                   out_hour = out_hour, qualfun = qualfun,
                                                   nout_fun = 5, outf_n = outf_n
        )),
        model
      )
    }
  stopCluster(clust)
  } else {
  
    if(cmethod == "LHC") {
      model_out <- setNames(
        lapply(model, function(mod_name) LHC_model(pars = params,
                                                   type = rep("met", (ncol(params)-1)),
                                                   model = mod_name, var = "temp",
                                                   config_file = config_file,
                                                   met = met_l[[mod_name]], folder = folder,
                                                   out_f = out_f, config_f = cnfg_l[[mod_name]],
                                                   obs_deps = obs_deps, obs_out = obs_out,
                                                   out_hour = out_hour, qualfun = qualfun,
                                                   nout_fun = 5, outf_n = outf_n
                                                  )),
        model
      )
    }
  }
##------------------------- MCMC calibration ----------------------------------------------------------
  
  if(cmethod == "MCMC") {
    model_out <- setNames(
                lapply(model, function(m){
                    FME::modMCMC(f = wrap_model, p = params, 
                                 type = rep("met",(length(params))),
                                 model = m,
                                 var = "temp",
                                 config_file = config_file,
                                 met = met_l[[m]],
                                 folder = folder,
                                 config_f = cnfg_l[[m]],
                                 out_f = out_f,  obs_deps = obs_deps, obs_out = obs_out,
                                 out_hour = out_hour,
                                 qualfun = function(O, P){
                                   ssr = sum((as.matrix(O[, -1]) - as.matrix(P[, -1]))^2)},
                                 outf_n = outf_n,
                                 niter = num, ...)}),
                model
    )
  }
  
##------------------------- MCMC calibration ----------------------------------------------------------
  
  if(cmethod == "modFit") {
    model_out <- setNames(
      lapply(model, function(m){
        FME::modFit(f = wrap_model, p = params_met,
                    type = rep("met",(length(params_met))),
                    model = m,
                    var = "temp",
                    config_file = config_file,
                    met = met_l[[m]],
                    folder = folder,
                    config_f = cnfg_l[[m]],
                    out_f = out_f,  obs_deps = obs_deps, obs_out = obs_out,
                    out_hour = out_hour,
                    qualfun = function(O, P){
                    res = as.vector(as.matrix(O[, -1]) - as.matrix(P[, -1]))},
                    out_name = "",
                    write = FALSE,
                    lower = p_lower_met,
                    upper = p_upper_met,
                    ...)}),
      model
    )
  }
  # return calibration results
  return(model_out)
}

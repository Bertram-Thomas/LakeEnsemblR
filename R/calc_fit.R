#' Calculate model performance metrics
#' 
#' Calculates model performace metrics from the netcdf file generated by running `run_ensemble`
#' 
#' @param ncdf Path to the netcdf file generated by running `run_ensemble`
#' @param list Alternatively to `ncdf` a list of siimulated variables, as returned by
#'    `run_ensemble()` when argument `return_list = TRUE`
#' @param model Vector of models for which to calculate the performance measures
#' @param var Variable for which to calculate the performance measures
#' @param qualfun Function to calculate the performance measures. Per default calculates root
#'    mean suqared error (rmse), Nash-Shutcliff efficiency (nse), Pearson correlation (r),
#'    relative error (re), and normalized mean absolute error (nmae). Can be any function that
#'    takes observed data as first, and simulated data at the same time and depth as the second
#'    argument
#' @param avfun Name of the function to calculate the ensemble average, defaults to "mean"
#' @author Johannes Feldbauer
#' @export
#' @examples 
#' \dontrun{
#' # using standard quality measures
#' calc_fit(ncdf = "output/ensemble_output.nc",
#'                    model = c("FLake", "GLM",  "GOTM", "Simstrat", "MyLake"),
#'                    var = "watertemp")
#' # using own performance measure
#'  calc_fit(ncdf = "output/ensemble_output.nc",
#'                   model = c("FLake", "GLM",  "GOTM", "Simstrat", "MyLake"),
#'                   var = "watertemp", qualfun = function(O, S) mean(O - S, na.rm = TRUE))
#' }
calc_fit <- function(ncdf, list = NULL, model, var, qualfun = qual_meas, avfun = "mean") {
  
  # check if model input is correct
  model <- check_models(model)
  
  if(is.null(list)) {
  # get variable
  var_list <- load_var(ncdf, var = var, return = "list", print = FALSE)
  } else {
    var_list <- list
    if(any(names(var_list) %in% paste0(c(model, "Obs"), "_", var))) {
      names(var_list) <- c(model, "Obs")
    }
  }
  
  # only the selected models
  var_list <- var_list[c(model, "Obs")]


  
  # only select depth where observations are available
  obs_col <- which(apply(var_list$Obs, 2, function(x)sum(!is.na(x))) != 0)
  
  var_list <- lapply(c(model, "Obs"), function(m) dplyr::select(var_list[[m]], obs_col))
  names(var_list) <- c(model, "Obs")

  
  # create list with long format data.frames
  var_long <-  lapply(model, function(m)
                       cbind(data.frame(reshape2::melt(var_list[[m]],id.vars = "datetime")),
                       data.frame(obs = reshape2::melt(var_list$Obs,id.vars = "datetime")$value)))
 
 names(var_long) <- model 
 
 # change water depth to nummeric
 var_long <- purrr::map(var_long,
                        function(m) dplyr::mutate(m, variable = -as.numeric(gsub("wtr_", "",
                                                                                 variable)))) 

 # calculate ensemble average
 ens_data <- var_long[[model[1]]]
 ens_data$value <- apply(sapply(model, function(m) var_long[[m]]$value), 1, get(avfun),
                         na.rm = TRUE)
 var_long[[paste0("ensemble_",avfun)]] <- ens_data
 
 # calculate quality measures
 qual <- lapply(var_long, function(m){qualfun(m$obs, m$value)})


 return(qual)
 

}

#' @noMd

qual_meas <- function(O, P){
  
  # function that calculates different estimations for model accuracy, namely: root mean squared
  # error (rmse), (Nash-Sutcliff) model efficiency (nse), Pearson corelation coefficient (r),
  # relative error (re) and normalized mean absolute error (nmae)
  #
  # Arguments:
  #^^^^^^^^^^
  # O: observed values
  # P: predicted values
  #
  # Return Value:
  #^^^^^^^^^^^^^^
  # qual: A data.frame containing the five quality estimates
  
  # rmse
  rmse <- sqrt(mean((O - P)^2, na.rm = TRUE))
  
  # nash sutcliff
  nse <- 1 - sum((O - P)^2, na.rm = TRUE)/sum((O - mean(O, na.rm=TRUE))^2, na.rm = TRUE)
  
  # pearson corelation coef
  r <- sum((O - mean(O, na.rm = TRUE))*(P - mean(P, na.rm = TRUE)),
           na.rm = TRUE)/sqrt(sum((O - mean(O, na.rm = TRUE))^2, na.rm = TRUE)*
                              sum((P - mean(P, na.rm = TRUE))^2, na.rm = TRUE))
  
  # relative error
  re <- mean((P - O)/O, na.rm = TRUE)
  
  # normalised mean absolute error
  nmae <- mean(abs((O - P)/O), na.rm = TRUE)
  
  qual <- data.frame(rmse = rmse, nse = nse, r = r, re = re, nmae = nmae)
  
  return(qual)
}
